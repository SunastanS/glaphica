---
phase: 04-channel-infrastructure
plan: 02
type: execute
wave: 2
depends_on: [01]
files_modified: [crates/renderer/src/renderer_init.rs, crates/glaphica/src/runtime/mod.rs]
autonomous: true
requirements: [CHAN-04, CHAN-05]
---

<objective>
Instantiate channels in GpuState::new() using engine::create_thread_channels()

Purpose: Create the channel infrastructure for true threading using RuntimeReceipt/RuntimeError types
Output: GpuState with channel fields, conditional compilation for true_threading mode
</objective>

<execution_context>
@/home/sunastans/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/sunastans/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@docs/planning/project.md
@docs/planning/roadmap.md
@docs/planning/requirements.md
@docs/planning/phases/04-channel-infrastructure/04-CONTEXT.md

# GpuState::new() location (where channels should be instantiated)
@crates/renderer/src/renderer_init.rs

# Channel creation helper (will use)
@crates/engine/src/lib.rs

# Protocol types (created in Plan 01)
@crates/protocol/src/lib.rs
</context>

<interfaces>
<!-- From Plan 01 - these types will exist after Plan 01 completes -->
```rust
// RuntimeReceipt and RuntimeError from protocol crate
pub enum RuntimeReceipt {
    ResourceAllocated { id: u64 },
    CommandCompleted { command_id: u64 },
}

pub enum RuntimeError {
    InvalidCommand { command_type: String },
    CommandFailed { error: String },
    ChannelClosed,
    Timeout { operation: String },
}

// Engine channel types
pub struct MainThreadChannels<Command, Receipt, Error> {
    pub input_control_queue: MainInputControlQueue,
    pub input_ring_producer: MainInputRingProducer,
    pub gpu_command_receiver: Consumer<GpuCmdMsg<Command>>,
    pub gpu_feedback_sender: Producer<GpuFeedbackFrame<Receipt, Error>>,
}

pub struct EngineThreadChannels<Command, Receipt, Error> {
    pub input_control_queue: EngineInputControlQueue,
    pub input_ring_consumer: EngineInputRingConsumer,
    pub gpu_command_sender: Producer<GpuCmdMsg<Command>>,
    pub gpu_feedback_receiver: Consumer<GpuFeedbackFrame<Receipt, Error>>,
}
```
</interfaces>

<tasks>

<task type="auto" tdd="true">
  <name>Task 1: Add channel fields to GpuState struct</name>
  <files>crates/renderer/src/renderer_init.rs</files>
  <behavior>
    - Test: GpuState has optional channel fields when true_threading feature enabled
    - Test: GpuState compiles without true_threading (fields gated with #[cfg])
  </behavior>
  <action>Add channel fields to GpuState struct in crates/renderer/src/renderer_init.rs:
```rust
pub struct GpuState {
    // ... existing fields ...
    
    #[cfg(feature = "true_threading")]
    pub main_thread_channels: Option<MainThreadChannels<RuntimeCommand, RuntimeReceipt, RuntimeError>>,
    
    #[cfg(feature = "true_threading")]
    pub engine_thread_channels: Option<EngineThreadChannels<RuntimeCommand, RuntimeReceipt, RuntimeError>>,
}
```
Use Option to allow single-threaded mode when feature disabled.</action>
  <verify>
    <automated>cargo check -p renderer --features true_threading && cargo check -p renderer</automated>
  </verify>
  <done>GpuState has channel fields gated by true_threading feature</done>
</task>

<task type="auto" tdd="true">
  <name>Task 2: Instantiate channels in GpuState::new()</name>
  <files>crates/renderer/src/renderer_init.rs</files>
  <behavior>
    - Test: Channels created with capacities from CONTEXT.md (1024/256/1024/256)
    - Test: GpuState::new() returns Result for error handling
    - Test: Channels stored in GpuState when true_threading enabled
  </behavior>
  <action>Modify GpuState::new() in crates/renderer/src/renderer_init.rs to instantiate channels:
```rust
// Before Renderer::new() call, create channels
#[cfg(feature = "true_threading")]
let (main_thread_channels, engine_thread_channels) = {
    use engine::create_thread_channels;
    
    // Capacities from CONTEXT.md
    let input_ring_capacity = 1024;
    let input_control_capacity = 256;
    let gpu_command_capacity = 1024;
    let gpu_feedback_capacity = 256;
    
    create_thread_channels::<RuntimeCommand, RuntimeReceipt, RuntimeError>(
        input_ring_capacity,
        input_control_capacity,
        gpu_command_capacity,
        gpu_feedback_capacity,
    )
};

// Later in GpuState construction:
GpuState {
    // ... existing fields ...
    #[cfg(feature = "true_threading")]
    main_thread_channels: Some(main_thread_channels),
    #[cfg(feature = "true_threading")]
    engine_thread_channels: Some(engine_thread_channels),
}
```
Ensure channel creation happens before Renderer::new() per CONTEXT.md initialization sequence.</action>
  <verify>
    <automated>cargo check -p renderer --features true_threading && cargo check -p renderer</automated>
  </verify>
  <done>Channels instantiated and stored in GpuState</done>
</task>

<task type="auto">
  <name>Task 3: Add RuntimeCommand type definition</name>
  <files>crates/renderer/src/renderer_init.rs</files>
  <action>Define RuntimeCommand enum as placeholder for Phase 2. Add to crates/renderer/src/renderer_init.rs or create new module:
```rust
#[derive(Debug, Clone, PartialEq)]
pub enum RuntimeCommand {
    /// Placeholder - Phase 2 will define all variants
    PresentFrame,
    Resize,
    EnqueueBrushCommands,
    PollMergeNotices,
}
```
This type is needed as the generic Command parameter for create_thread_channels().</action>
  <verify>
    <automated>cargo check -p renderer --features true_threading</automated>
  </verify>
  <done>RuntimeCommand defined with placeholder variants</done>
</task>

</tasks>

<verification>
- [ ] `cargo check -p renderer --features true_threading` succeeds
- [ ] `cargo check -p renderer` succeeds (without feature)
- [ ] GpuState has channel fields when true_threading enabled
- [ ] Channels created with correct capacities (1024/256/1024/256)
- [ ] RuntimeCommand type defined
</verification>

<success_criteria>
1. GpuState struct has main_thread_channels and engine_thread_channels fields
2. Fields are conditionally compiled with #[cfg(feature = "true_threading")]
3. GpuState::new() calls engine::create_thread_channels()
4. Channel capacities match CONTEXT.md (input_ring=1024, input_control=256, gpu_command=1024, gpu_feedback=256)
5. RuntimeCommand type defined with placeholder variants
6. Code compiles with and without true_threading feature
</success_criteria>

<must_haves>
  truths:
    - "Channels are created when GpuState is initialized"
    - "Code compiles in both single-threaded and true-threaded modes"
    - "Channel capacities are configurable constants"
  artifacts:
    - path: "crates/renderer/src/renderer_init.rs"
      provides: "GpuState with channel fields"
      contains: "main_thread_channels"
    - path: "crates/renderer/src/renderer_init.rs"
      provides: "RuntimeCommand enum"
      min_lines: 10
  key_links:
    - from: "GpuState::new()"
      to: "engine::create_thread_channels()"
      via: "channel instantiation"
      pattern: "create_thread_channels::<RuntimeCommand"
</must_haves>

<output>
After completion, create `docs/planning/phases/04-channel-infrastructure/04-02-SUMMARY.md`
</output>
