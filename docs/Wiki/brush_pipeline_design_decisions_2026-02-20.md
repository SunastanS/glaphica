# 笔刷流水线关键设计决策（2026-02-20）

本文档记录本次讨论中已经达成的一组关键架构决策，用于后续实现与复盘。

## 背景

- 当前路径：笔刷在热路径先写入 buffer，空闲时再合并到真实图像。
- 数据组织：buffer 和真实图像都采用 tile 化。
- 当前基础常量中 `TILE_SIZE` 为 256（后续决议会调整）。

## 决策 1：撤销路径优先采用版本化（写时复制）

### 结论

- 先采用 **写时复制（COW）** 路线。
- 撤销栈以 **版本化 tile key 映射回滚** 为主，而不是原地写 + 差分回滚。

### 备选方案

1. COW：写入时分配新 tile，保留旧 tile 供撤销。
2. 原地写：直接改原 tile，额外维护脏矩形/差分撤销结构。

### 选择理由

- 在本项目 GPU 原生约束下，差分撤销也很难绕开 tile 化预分配，并不会天然显著省缓存。
- COW 心智模型更清晰，失败域更小，易于在早期把流水线跑通。
- 原地写方案在并发、差分边界、恢复一致性上复杂度更高，当前阶段风险偏高。

### 实施原则

- 采用 **按 stroke + touched tile 粒度 COW**，避免“每个 dab 都分配新 tile”。
- 在 merge 新笔画时，一次统一为受影响的 tiles 进行 Copy on Write 并分配新 key

## 决策 2：tile 大小短期定为 128（不选 64）

### 结论

- 短期将 tile 大小从 256 调整为 **128**。
- 暂不采用 64；暂不做“任意 tile size 可配置化”重构。

### 备选方案

1. 128x128，保持 32x32 tiles/atlas。
2. 64x64，切换为 64x64 tiles/atlas。

### 选择理由（业务优先级）

- 业务上更关注小笔刷的交互延迟（线条场景的 P 优先级高于大面积 A）。
- 但在无选区涂色场景，存在常见的大笔刷使用（约 256px）需求：
  - 128 下，256px 笔刷单 dab 最多约 9 tiles；
  - 64 下，256px 笔刷单 dab 最多约 25 tiles。
- 64 在该场景会显著放大触达 tile 数和调度成本，短期不可接受。
- 128 相比 256 能降低撤销/更新粒度粗糙问题，同时避免 64 的高 tile 触达爆炸。

## 决策 3：实施顺序

### 结论

- 先调整 tile 到 128，再实现 COW 合并与版本化撤销链路。

### 理由

- tile 大小会直接影响 merge 粒度、触达 tile 集、撤销记录规模。
- 若先做流水线再改 tile，会导致同一逻辑二次调试与二次验证。

## 量化评估框架（后续）

为防止后续再次陷入纯主观争论，保留如下统一指标：

- `tile_per_dab`（P50/P95/P99）
- `new_key_per_stroke`（COW 压力）
- `merge_gpu_ms`（GPU 合并耗时）
- `pending_dab_count / queue_backlog`（调度积压）
- `input_to_visible_latency_ms`（线条场景 P95/P99）

后续若评估 64，应以以上指标 A/B 对比后再决策，不凭直觉切换。

## 已知边界与风险

- 当前 merge 执行路径尚未完全落地，文档结论以“指导实现顺序”为主。
- 切换到 128 时需同步 CPU 常量与 WGSL 常量，防止渲染坐标体系不致。
- 撤销栈需与 tile 生命周期回收策略严格对齐，避免回滚引用悬挂。

## 下一步（实现导向）

1. 将 `TILE_SIZE` 与相关 shader 常量统一为 128，并完成现有测试更新。
2. 落地 `dispatch_brush_merge` 的最小可用闭环（按 touched tile 生成 new key）。
3. 建立按 stroke 的版本化撤销记录 `{old_key, new_key}` 并验证回滚。
4. 接入上述量化指标，为后续是否尝试 64 提供客观依据。
