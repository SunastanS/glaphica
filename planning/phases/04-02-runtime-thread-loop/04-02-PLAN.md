---
phase: 04-02-runtime-thread-loop
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/glaphica/src/runtime/mod.rs
  - crates/glaphica/src/runtime/execution.rs
autonomous: true
requirements:
  - LOOP-01
  - LOOP-02
  - LOOP-03
  - LOOP-04
  - LOOP-05
must_haves:
  truths:
    - "GpuRuntime::spawn_runtime_thread() creates a dedicated thread"
    - "Runtime thread consumes commands from gpu_command_receiver"
    - "Runtime thread produces feedback via gpu_feedback_sender"
    - "All RuntimeCommand variants are handled in the thread loop"
    - "Graceful shutdown occurs via control channel or disconnect"
  artifacts:
    - path: "crates/glaphica/src/runtime/execution.rs"
      provides: "Runtime thread loop implementation"
      min_lines: 100
    - path: "crates/glaphica/src/runtime/mod.rs"
      provides: "GpuRuntime::spawn_runtime_thread() method"
      contains: "pub fn spawn_runtime_thread"
  key_links:
    - from: "crates/glaphica/src/runtime/execution.rs"
      to: "engine::EngineThreadChannels"
      via: "channel consumption"
      pattern: "gpu_command_receiver\\.(pop|recv)"
    - from: "crates/glaphica/src/runtime/execution.rs"
      to: "engine::EngineThreadChannels"
      via: "feedback production"
      pattern: "gpu_feedback_sender\\.push"
---

<objective>
Create runtime thread spawn function and implement the core command consumption loop with feedback production.

Purpose: Decouple command execution from the main thread, enabling true multi-threaded rendering while maintaining correctness through channel-based communication.

Output: 
- `GpuRuntime::spawn_runtime_thread()` method
- Runtime thread loop that handles all `RuntimeCommand` variants
- Feedback channel integration
</objective>

<execution_context>
@/home/sunastans/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/sunastans/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@docs/planning/roadmap.md
@docs/planning/requirements.md
@docs/planning/state.md
@crates/glaphica/src/runtime/mod.rs
@crates/glaphica/src/runtime/protocol.rs
@crates/glaphica/src/app_core/mod.rs
</context>

<interfaces>
<!-- Key types from existing code - executor uses these directly -->

From crates/glaphica/src/runtime/protocol.rs:
```rust
pub enum RuntimeCommand {
    PresentFrame { frame_id: u64 },
    Resize { width: u32, height: u32, view_transform: ViewTransform },
    ResizeHandshake { width: u32, height: u32, ack_sender: Sender<Result<(), RuntimeError>> },
    Init { ack_sender: Sender<Result<(), RuntimeError>> },
    Shutdown { reason: String },
    BindRenderTree { snapshot: RenderTreeSnapshot, reason: &'static str },
    EnqueueBrushCommands { commands: Vec<BrushRenderCommand> },
    EnqueueBrushCommand { command: BrushRenderCommand },
    PollMergeNotices { frame_id: u64 },
    ProcessMergeCompletions { frame_id: u64 },
    AckMergeResults { notices: Vec<MergeCompletionNotice> },
    EnqueuePlannedMerge { receipt: StrokeExecutionReceipt, gpu_merge_ops: Vec<GpuMergeOp>, meta: MergePlanMeta },
}

pub enum RuntimeReceipt {
    FramePresented { executed_tile_count: usize },
    Resized,
    ResizeHandshakeAck,
    InitComplete,
    ShutdownAck { reason: String },
    RenderTreeBound,
    BrushCommandsEnqueued { dab_count: u64 },
    BrushCommandEnqueued,
    MergeNotices { notices: Vec<MergeCompletionNotice> },
    MergeCompletionsProcessed { submission_receipt_ids: Vec<StrokeExecutionReceiptId>, renderer_notices: Vec<RendererNotice> },
    MergeResultsAcknowledged,
    PlannedMergeEnqueued,
}

pub enum RuntimeError {
    PresentError(renderer::PresentError),
    SurfaceError(wgpu::SurfaceError),
    ResizeError(String),
    BrushEnqueueError(renderer::BrushRenderEnqueueError),
    MergeSubmit(renderer::MergeSubmitError),
    MergePoll(renderer::MergePollError),
    MergeAck(renderer::MergeAckError),
    MergeEnqueue(renderer::MergeEnqueueError),
    ShutdownRequested { reason: String },
    EngineThreadDisconnected,
    FeedbackQueueTimeout,
    HandshakeTimeout { operation: &'static str },
}
```

From crates/renderer/src/lib.rs (channel infrastructure from Phase 4.1):
```rust
#[cfg(feature = "true_threading")]
main_thread_channels: Option<engine::MainThreadChannels<RuntimeCommand, protocol::RuntimeReceipt, protocol::RuntimeError>>,

#[cfg(feature = "true_threading")]
engine_thread_channels: Option<engine::EngineThreadChannels<RuntimeCommand, protocol::RuntimeReceipt, protocol::RuntimeError>>,
```
</interfaces>

<tasks>

<task type="auto" tdd="true">
  <name>Task 1: Create runtime thread spawn function</name>
  <files>crates/glaphica/src/runtime/mod.rs, crates/glaphica/src/runtime/execution.rs</files>
  <behavior>
    - Test: spawn_runtime_thread() returns JoinHandle&lt;()&gt;
    - Test: Thread consumes at least one command from channel
    - Test: Thread produces corresponding receipt on feedback channel
    - Edge case: Channel disconnect should cause graceful thread exit
  </behavior>
  <action>
    1. Create new file `crates/glaphica/src/runtime/execution.rs`
    2. Add `mod execution;` to `crates/glaphica/src/runtime/mod.rs`
    3. Implement `GpuRuntime::spawn_runtime_thread()` method that:
       - Takes `&mut self` and consumes `engine_thread_channels` from `GpuState`
       - Spawns a thread using `std::thread::spawn()`
       - Thread owns the `EngineThreadChannels` and runs the command loop
       - Returns `std::thread::JoinHandle<()>`
    4. Store the `JoinHandle` in a new field on `GpuRuntime`: `runtime_thread_handle: Option<std::thread::JoinHandle<()>>`
    5. Add initialization in `GpuRuntime::new()` to set `runtime_thread_handle: None`
  </action>
  <verify>
    <automated>cargo test -p glaphica runtime_thread_spawn -- --nocapture</automated>
  </verify>
  <done>
    - `GpuRuntime::spawn_runtime_thread()` method exists and compiles
    - Method returns `JoinHandle<()>`
    - Runtime thread stored in `GpuRuntime` struct
    - Test passes: thread spawns, consumes command, produces receipt
  </done>
</task>

<task type="auto" tdd="true">
  <name>Task 2: Implement command consumption loop</name>
  <files>crates/glaphica/src/runtime/execution.rs</files>
  <behavior>
    - Test: Thread loop blocks on `gpu_command_receiver.pop()` or `recv_timeout()`
    - Test: Each command variant is matched and handled
    - Test: Corresponding receipt is sent via `gpu_feedback_sender.push()`
    - Edge case: Shutdown command causes loop to exit gracefully
  </behavior>
  <action>
    1. In `execution.rs`, implement `runtime_thread_loop()` function that:
       - Takes ownership of `EngineThreadChannels&lt;RuntimeCommand, RuntimeReceipt, RuntimeError&gt;`
       - Runs infinite loop: `loop { match command_receiver.pop() { ... } }`
       - For shutdown detection, use `recv_timeout(Duration::from_millis(100))` and check a shutdown flag
       - Each `RuntimeCommand` variant calls `runtime.execute(command)` and pushes result to feedback sender
    2. Handle all 12 `RuntimeCommand` variants from `protocol.rs`:
       - `PresentFrame` → `FramePresented` receipt
       - `Resize` → `Resized` receipt
       - `ResizeHandshake` → `ResizeHandshakeAck` receipt (with handshake via ack_sender)
       - `Init` → `InitComplete` receipt (with handshake via ack_sender)
       - `Shutdown` → `ShutdownAck` receipt, then break loop
       - `BindRenderTree` → `RenderTreeBound` receipt
       - `EnqueueBrushCommands` → `BrushCommandsEnqueued` receipt
       - `EnqueueBrushCommand` → `BrushCommandEnqueued` receipt
       - `PollMergeNotices` → `MergeNotices` receipt
       - `ProcessMergeCompletions` → `MergeCompletionsProcessed` receipt
       - `AckMergeResults` → `MergeResultsAcknowledged` receipt
       - `EnqueuePlannedMerge` → `PlannedMergeEnqueued` receipt
    3. Error handling: if `execute()` returns `Err`, push error to feedback sender and continue
    4. Handle `pop()` returning `None` (channel disconnected) → break loop
  </action>
  <verify>
    <automated>cargo test -p glaphica runtime_thread_loop -- --nocapture</automated>
  </verify>
  <done>
    - Runtime thread loop implemented with match on all RuntimeCommand variants
    - Each command produces corresponding receipt via feedback channel
    - Shutdown command causes loop to exit
    - Channel disconnect causes loop to exit
    - Test passes: send 3+ different commands, verify 3+ receipts received
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement graceful shutdown mechanism</name>
  <files>crates/glaphica/src/runtime/execution.rs, crates/glaphica/src/runtime/mod.rs</files>
  <action>
    1. Add shutdown mechanism using `InputControlEvent` pattern or dedicated shutdown channel:
       - Option A: Use `recv_timeout()` in loop and check an `AtomicBool` shutdown flag
       - Option B: Use a separate control channel (`mpsc::Receiver&lt;ControlMessage&gt;`)
       - Recommended: Use `recv_timeout(Duration::from_millis(100))` and check `AtomicBool` for simplicity
    2. Add field to `GpuRuntime`: `shutdown_flag: Arc&lt;AtomicBool&gt;`
    3. Implement `GpuRuntime::request_shutdown(&self, reason: &str)` method that:
       - Sets the shutdown flag to `true`
       - Optionally sends a `Shutdown { reason }` command through the command channel
    4. In `runtime_thread_loop()`:
       - Check shutdown flag after each command processing
       - If flag is `true`, break loop and return
       - Handle `Shutdown` command by breaking loop
    5. In `drop impl for GpuRuntime`: call `request_shutdown()` and `join()` the thread with timeout
  </action>
  <verify>
    <automated>cargo test -p glaphica runtime_shutdown -- --nocapture</automated>
  </verify>
  <done>
    - `GpuRuntime::request_shutdown()` method exists
    - Runtime thread checks shutdown flag and exits gracefully
    - Thread joins successfully on drop (no hanging)
    - Test passes: spawn thread, request shutdown, verify thread exits within 1 second
  </done>
</task>

<task type="auto">
  <name>Task 4: Handle RuntimeCommand variants with proper error routing</name>
  <files>crates/glaphica/src/runtime/execution.rs</files>
  <action>
    1. Review existing `GpuRuntime::execute()` implementation in `mod.rs` (lines 60-200)
    2. In `execution.rs`, wrap each command execution in error handling:
       ```rust
       match runtime.execute(command) {
           Ok(receipt) => {
               if feedback_sender.push(Ok(receipt)).is_err() {
                   // Feedback channel disconnected, exit loop
                   break;
               }
           }
           Err(error) => {
               // Push error to feedback channel
               let _ = feedback_sender.push(Err(error));
               // Continue processing next commands
           }
       }
       ```
    3. For handshake commands (`ResizeHandshake`, `Init`):
       - Send handshake ack via `ack_sender.send(Ok(()))` BEFORE pushing receipt
       - Handle `ack_sender.send(Err())` by not pushing receipt
    4. Ensure all 12 variants are handled:
       - Standard commands: PresentFrame, Resize, BindRenderTree, EnqueueBrushCommands, EnqueueBrushCommand, PollMergeNotices, ProcessMergeCompletions, AckMergeResults, EnqueuePlannedMerge
       - Handshake commands: ResizeHandshake, Init
       - Control commands: Shutdown
  </action>
  <verify>
    <automated>cargo test -p glaphica runtime_error_handling -- --nocapture</automated>
  </verify>
  <done>
    - All 12 RuntimeCommand variants handled in match statement
    - Errors pushed to feedback channel, loop continues
    - Handshake acks sent before receipts
    - Test passes: inject error, verify error received on feedback channel, loop continues
  </done>
</task>

</tasks>

<verification>
Phase 4.2 verification:
1. `GpuRuntime::spawn_runtime_thread()` creates thread that owns `EngineThreadChannels`
2. Thread loop uses `gpu_command_receiver.pop()` or `recv_timeout()` for consumption
3. Feedback sent via `gpu_feedback_sender.push()` for each command
4. All 12 `RuntimeCommand` variants handled with corresponding `RuntimeReceipt`
5. Shutdown mechanism works: flag + join with timeout
6. Error handling: errors pushed to feedback, loop continues

Manual verification (if tests not comprehensive):
- Build with `--features true_threading`
- Verify code compiles without warnings
- Run existing renderer tests: `cargo test -p renderer -- --nocapture`
</verification>

<success_criteria>
1. ✓ Runtime thread spawns successfully
2. ✓ Command loop consumes from channel
3. ✓ Feedback channel produces receipts
4. ✓ All 12 RuntimeCommand variants handled
5. ✓ Graceful shutdown implemented
6. ✓ Error handling routes errors to feedback channel
7. ✓ Code compiles with `true_threading` feature
8. ✓ No new dead_code warnings introduced
</success_criteria>

<output>
After completion, create `docs/planning/phases/04-02-runtime-thread-loop/04-01-SUMMARY.md` documenting:
- Implementation approach
- Thread loop structure
- Error handling strategy
- Any deviations from plan
</output>
