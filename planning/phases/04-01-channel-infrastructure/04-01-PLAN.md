---
phase: 04-channel-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [crates/glaphica/Cargo.toml, crates/protocol/src/lib.rs]
autonomous: true
requirements: [CHAN-01, CHAN-02, CHAN-03]
---

<objective>
Add dependencies and define RuntimeReceipt/RuntimeError types in protocol crate

Purpose: Establish the generic types required by engine::create_thread_channels() for true threading
Output: Updated Cargo.toml with feature flag, new Receipt/Error enums in protocol crate
</objective>

<execution_context>
@/home/sunastans/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/sunastans/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@docs/planning/project.md
@docs/planning/roadmap.md
@docs/planning/requirements.md
@docs/planning/phases/04-channel-infrastructure/04-CONTEXT.md

# Existing protocol types (use GpuFeedbackFrame pattern)
@crates/protocol/src/lib.rs

# Engine channel creation helper (will use directly)
@crates/engine/src/lib.rs
</context>

<interfaces>
<!-- Key types from protocol crate - use as reference for Receipt/Error design -->

```rust
// GpuFeedbackFrame already supports generic Receipt/Error
pub struct GpuFeedbackFrame<Receipt, Error> {
    pub present_frame_id: PresentFrameId,
    pub submit_waterline: SubmitWaterline,
    pub executed_batch_waterline: ExecutedBatchWaterline,
    pub complete_waterline: CompleteWaterline,
    pub receipts: SmallVec<[Receipt; 4]>,
    pub errors: SmallVec<[Error; 4]>,
}

// Test types available for unit tests
pub mod merge_test_support {
    pub struct TestReceipt { pub key: u64, pub payload_version: u64 }
    pub struct TestError { pub key: u64 }
}
```

<!-- Engine channel creation helper - will use in Task 2 -->
```rust
// engine::create_thread_channels<Command, Receipt, Error>()
pub fn create_thread_channels<Command, Receipt, Error>(
    input_ring_capacity: usize,
    input_control_capacity: usize,
    gpu_command_capacity: usize,
    gpu_feedback_capacity: usize,
) -> (
    MainThreadChannels<Command, Receipt, Error>,
    EngineThreadChannels<Command, Receipt, Error>,
)
```
</interfaces>

<tasks>

<task type="auto" tdd="true">
  <name>Task 1: Add true_threading feature flag to glaphica/Cargo.toml</name>
  <files>crates/glaphica/Cargo.toml</files>
  <behavior>
    - Test: Feature flag exists and compiles with/without flag
    - Test: engine and protocol dependencies are present
  </behavior>
  <action>Add feature flag section to crates/glaphica/Cargo.toml:
```toml
[features]
true_threading = []
```
Verify dependencies exist:
```toml
engine = { path = "../engine" }
protocol = { path = "../protocol" }
```
(These should already exist per context - just add the feature flag)</action>
  <verify>
    <automated>cargo check -p glaphica --features true_threading && cargo check -p glaphica</automated>
  </verify>
  <done>Feature flag added, compiles with and without true_threading</done>
</task>

<task type="auto" tdd="true">
  <name>Task 2: Define RuntimeReceipt enum in protocol crate</name>
  <files>crates/protocol/src/lib.rs</files>
  <behavior>
    - Test: RuntimeReceipt implements Debug, Clone, PartialEq, Eq
    - Test: RuntimeReceipt has variants for resource allocation acknowledgments
    - Test: RuntimeReceipt implements MergeItem trait for feedback merging
  </behavior>
  <action>Add RuntimeReceipt enum to crates/protocol/src/lib.rs after GpuFeedbackFrame:
```rust
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum RuntimeReceipt {
    /// Resource allocation completed successfully
    ResourceAllocated { id: u64 },
    /// Command completed with result
    CommandCompleted { command_id: u64 },
}

impl MergeItem for RuntimeReceipt {
    type MergeKey = u64;
    
    fn merge_key(&self) -> Self::MergeKey {
        match self {
            RuntimeReceipt::ResourceAllocated { id } => *id,
            RuntimeReceipt::CommandCompleted { command_id } => *command_id,
        }
    }
    
    fn merge_duplicate(existing: &mut Self, incoming: Self) {
        // Replace with newer receipt
        *existing = incoming;
    }
}
```
Note: Per CONTEXT.md, most commands use waterline tracking - receipts only for exceptional cases.</action>
  <verify>
    <automated>cargo test -p protocol -- --nocapture</automated>
  </verify>
  <done>RuntimeReceipt defined with MergeItem implementation</done>
</task>

<task type="auto" tdd="true">
  <name>Task 3: Define RuntimeError enum in protocol crate</name>
  <files>crates/protocol/src/lib.rs</files>
  <behavior>
    - Test: RuntimeError implements Debug, Clone, PartialEq, Eq
    - Test: RuntimeError covers command-level failures (not GPU details)
    - Test: RuntimeError implements MergeItem trait
  </behavior>
  <action>Add RuntimeError enum to crates/protocol/src/lib.rs after RuntimeReceipt:
```rust
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum RuntimeError {
    /// Command type not recognized
    InvalidCommand { command_type: String },
    /// Command execution failed
    CommandFailed { error: String },
    /// Channel closed unexpectedly
    ChannelClosed,
    /// Operation timed out
    Timeout { operation: String },
}

impl MergeItem for RuntimeError {
    type MergeKey = u64;
    
    fn merge_key(&self) -> Self::MergeKey {
        // Use hash of error variant for dedup
        match self {
            RuntimeError::InvalidCommand { command_type } => command_type.len() as u64,
            RuntimeError::CommandFailed { error } => error.len() as u64,
            RuntimeError::ChannelClosed => 0,
            RuntimeError::Timeout { operation } => operation.len() as u64,
        }
    }
}
```
Per CONTEXT.md: All errors are fatal (fail fast), abstract wgpu details.</action>
  <verify>
    <automated>cargo test -p protocol -- --nocapture</automated>
  </verify>
  <done>RuntimeError defined with MergeItem implementation</done>
</task>

</tasks>

<verification>
- [ ] `cargo check -p glaphica --features true_threading` succeeds
- [ ] `cargo check -p glaphica` succeeds (without feature)
- [ ] `cargo test -p protocol` passes all tests
- [ ] RuntimeReceipt has MergeItem implementation
- [ ] RuntimeError has MergeItem implementation
</verification>

<success_criteria>
1. Feature flag `true_threading` exists in crates/glaphica/Cargo.toml
2. RuntimeReceipt enum defined with 2+ variants
3. RuntimeError enum defined with 4 variants (InvalidCommand, CommandFailed, ChannelClosed, Timeout)
4. Both types implement MergeItem for feedback merging
5. Code compiles with and without true_threading feature
</success_criteria>

<output>
After completion, create `docs/planning/phases/04-channel-infrastructure/04-01-SUMMARY.md`
</output>
