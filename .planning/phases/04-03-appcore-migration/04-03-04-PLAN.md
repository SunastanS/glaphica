---
phase: 04-03-appcore-migration
plan: 04
type: execute
wave: 4
depends_on: [04-03-03]
files_modified:
  - crates/glaphica/src/app_core/mod.rs
  - crates/glaphica/src/tests.rs
autonomous: true
gap_closure: true
requirements: [CMD-05, TEST-02]

must_haves:
  truths:
    - "AppCore::process_feedback() consumes GpuFeedbackFrame from channel"
    - "Waterlines are updated from feedback frames"
    - "All 47 renderer tests pass in two-thread mode"
    - "All 31 glaphica tests pass with true_threading feature"
  artifacts:
    - path: "crates/glaphica/src/app_core/mod.rs"
      provides: "Feedback processing method"
      contains: "process_feedback"
    - path: "crates/glaphica/src/tests.rs"
      provides: "Integration tests for channel-based AppCore"
  key_links:
    - from: "gpu_feedback_receiver"
      to: "AppCore::process_feedback()"
      via: "GpuFeedbackFrame"
      pattern: "gpu_feedback_receiver.pop"
    - from: "process_feedback()"
      to: "waterlines"
      via: "frame.update"
---

<objective>
Implement feedback processing in AppCore and verify all tests pass with channel-based communication.

Purpose: Complete the bidirectional channel communication by implementing feedback consumption and ensure all tests pass.
Output: AppCore::process_feedback() method, passing tests in both single-threaded and threaded modes.
</objective>

<execution_context>
@/home/sunastans/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/sunastans/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior Plan Context
@.planning/phases/04-03-appcore-migration/04-03-03-PLAN.md

<interfaces>
<!-- Feedback processing pattern from EngineCore -->

From crates/glaphica/src/engine_core.rs:
```rust
pub fn process_feedback(&mut self, frame: GpuFeedbackFrame<RuntimeReceipt, RuntimeError>) {
    // 1. Update waterlines (max merge - monotonic guarantee)
    self.waterlines.submit = self.waterlines.submit.max(frame.submit_waterline);
    self.waterlines.executed = self.waterlines.executed.max(frame.executed_batch_waterline);
    self.waterlines.complete = self.waterlines.complete.max(frame.complete_waterline);

    // 2. Process receipts
    for receipt in frame.receipts.iter() {
        self.apply_receipt(receipt);
    }

    // 3. Process errors
    for error in frame.errors.iter() {
        self.handle_error(error);
    }

    // 4. GC eviction based on complete_waterline
    self.gc_evict_before_waterline(self.waterlines.complete);
}
```

From crates/protocol/src/lib.rs:
```rust
pub struct GpuFeedbackFrame<Receipt, Error> {
    pub receipts: Vec<Receipt>,
    pub errors: Vec<Error>,
    pub submit_waterline: SubmitWaterline,
    pub executed_batch_waterline: ExecutedBatchWaterline,
    pub complete_waterline: CompleteWaterline,
}
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add waterline tracking fields to AppCore</name>
  <files>crates/glaphica/src/app_core/mod.rs</files>
  <action>
Add waterline tracking fields to AppCore (similar to EngineCore):

```rust
pub struct AppCore {
    // ... existing fields ...
    
    /// Waterlines for GPU completion tracking (threaded mode).
    /// Tracks submit, executed, and complete waterlines from feedback.
    #[cfg(feature = "true_threading")]
    waterlines: Option<EngineWaterlines>,
}

/// Waterlines struct (can reuse from engine_core or define locally)
#[cfg(feature = "true_threading")]
#[derive(Debug, Clone, Copy)]
pub struct EngineWaterlines {
    pub submit: protocol::SubmitWaterline,
    pub executed: protocol::ExecutedBatchWaterline,
    pub complete: protocol::CompleteWaterline,
}
```

Initialize in new_with_channels():
```rust
#[cfg(feature = "true_threading")]
waterlines: Some(EngineWaterlines::default()),
```
  </action>
  <verify>
    <automated>cargo check -p glaphica --features true_threading</automated>
  </verify>
  <done>AppCore has waterlines field for feedback tracking in threaded mode</done>
</task>

<task type="auto">
  <name>Task 2: Implement AppCore::process_feedback()</name>
  <files>crates/glaphica/src/app_core/mod.rs</files>
  <action>
Implement feedback processing method in AppCore:

```rust
#[cfg(feature = "true_threading")]
impl AppCore {
    /// Process a feedback frame from the main thread.
    /// 
    /// Updates waterlines, processes receipts/errors, and triggers GC.
    pub fn process_feedback(&mut self, frame: protocol::GpuFeedbackFrame<RuntimeReceipt, RuntimeError>) {
        // Update waterlines (max merge - monotonic guarantee)
        if let Some(ref mut wl) = self.waterlines {
            wl.submit = wl.submit.max(frame.submit_waterline);
            wl.executed = wl.executed.max(frame.executed_batch_waterline);
            wl.complete = wl.complete.max(frame.complete_waterline);
        }
        
        // Process receipts (merge completions, etc.)
        for receipt in frame.receipts.iter() {
            self.apply_receipt(receipt);
        }
        
        // Process errors
        for error in frame.errors.iter() {
            self.handle_feedback_error(error);
        }
        
        // GC eviction based on complete_waterline
        self.gc_evict_based_on_waterline();
    }
    
    fn apply_receipt(&mut self, receipt: &RuntimeReceipt) {
        match receipt {
            RuntimeReceipt::MergeCompletionsProcessed { .. } => {
                // Handle merge completion - may need to update internal state
            }
            RuntimeReceipt::FramePresented { .. } => {
                // Frame completed
            }
            _ => {}
        }
    }
    
    fn handle_feedback_error(&mut self, error: &RuntimeError) {
        eprintln!("[app_core] feedback error: {:?}", error);
    }
    
    fn gc_evict_based_on_waterline(&mut self) {
        // Use waterlines.complete to determine safe-to-release tiles
        // Implementation depends on tile lifetime tracking
    }
}
```

This mirrors the pattern from EngineCore::process_feedback().
  </action>
  <verify>
    <automated>cargo check -p glaphica --features true_threading</automated>
  </verify>
  <done>AppCore::process_feedback() implemented with waterline updates and receipt processing</done>
</task>

<task type="auto">
  <name>Task 3: Add integration test for channel-based AppCore</name>
  <files>crates/glaphica/src/tests.rs</files>
  <action>
Add integration test to verify channel-based communication works:

```rust
#[cfg(feature = "true_threading")]
#[test]
fn test_appcore_channel_communication() {
    use engine::create_thread_channels;
    use protocol::GpuCmdMsg;
    
    // Create channels
    let (main_channels, engine_channels) = create_thread_channels::<
        RuntimeCommand, RuntimeReceipt, RuntimeError
    >(1024, 64, 256, 64);
    
    // Create AppCore with channels
    let app_core = AppCore::new_with_channels(
        // ... required parameters ...
        engine_channels.gpu_command_sender,
        engine_channels.gpu_feedback_receiver,
    );
    
    // Verify channel fields are Some
    assert!(app_core.has_channels());
    
    // Test command send
    let cmd = RuntimeCommand::PresentFrame { frame_id: 1 };
    // ... verify command can be sent via channel ...
    
    // Test feedback receive
    // ... verify feedback can be received ...
}

#[cfg(feature = "true_threading")]
#[test]
fn test_appcore_single_threaded_fallback() {
    // Create AppCore without channels (single-threaded mode)
    let app_core = AppCore::new(/* ... parameters ... */);
    
    // Verify channel fields are None
    assert!(!app_core.has_channels());
}
```
  </action>
  <verify>
    <automated>cargo test -p glaphica --features true_threading -- --test-threads=1 --nocapture test_appcore_channel 2>&1 | head -50</automated>
  </verify>
  <done>Integration tests for channel-based AppCore created and passing</done>
</task>

<task type="auto">
  <name>Task 4: Run full test suite in both modes</name>
  <files>crates/glaphica/src/tests.rs</files>
  <action>
Run full test suite to verify no regressions:

1. Run glaphica tests in single-threaded mode:
```bash
cargo test -p glaphica
```

2. Run glaphica tests in threaded mode:
```bash
cargo test -p glaphica --features true_threading
```

3. Run renderer tests:
```bash
cargo test -p renderer --features true_threading
```

4. Verify test counts match expected:
   - glaphica: 31 tests
   - renderer: 47-48 tests

Document any failures and investigate if related to channel changes.
  </action>
  <verify>
    <automated>cargo test -p glaphica --features true_threading 2>&1 | tail -20</automated>
  </verify>
  <done>All tests pass in both single-threaded and threaded modes</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `cargo test -p glaphica` passes (single-threaded mode) - expect 31 tests
2. `cargo test -p glaphica --features true_threading` passes (threaded mode)
3. `cargo test -p renderer --features true_threading` passes - expect 47-48 tests
4. No dead_code warnings introduced
</verification>

<success_criteria>
1. AppCore::process_feedback() implemented and functional
2. Waterlines updated from feedback frames
3. Integration tests for channel communication passing
4. All existing tests continue to pass in both modes
5. TEST-02 requirement satisfied: All 47 renderer tests pass in two-thread mode
</success_criteria>

<output>
After completion, create `.planning/phases/04-03-appcore-migration/04-03-04-SUMMARY.md`
</output>