---
phase: 04-03-appcore-migration
plan: 01
type: execute
wave: 1
depends_on:
  - 04-01-channel-infrastructure
  - 04-02-runtime-thread-loop
files_modified:
  - crates/glaphica/src/app_core/mod.rs
  - crates/glaphica/src/engine_core.rs
  - crates/glaphica/src/engine_bridge.rs
  - crates/glaphica/src/lib.rs
autonomous: false
requirements:
  - CMD-01
  - CMD-02
  - CMD-03
  - CMD-04
  - CMD-05
status: blocked
blocker: |
  AppCore has NOT been migrated to use channels. Current architecture uses
  direct `runtime.execute()` calls. Infrastructure exists (Phases 4.1 & 4.2)
  but integration is missing.
  
  See: 04-03-VERIFICATION.md for detailed gap analysis.
must_haves:
  truths:
    - "AppCore::render() sends RuntimeCommand::PresentFrame via channel"
    - "AppCore::resize() sends RuntimeCommand::Resize synchronously"
    - "AppCore::enqueue_brush_render_command() sends RuntimeCommand::EnqueueBrushCommands"
    - "EngineCore consumes GpuFeedbackFrame from channel"
    - "Waterline tracking updated from feedback"
  artifacts:
    - path: "crates/glaphica/src/app_core/mod.rs"
      provides: "Channel-based command sending"
      contains: "gpu_command_sender.push"
      status: NOT IMPLEMENTED (uses runtime.execute() directly)
    - path: "crates/glaphica/src/engine_core.rs"
      provides: "Feedback consumption"
      contains: "process_feedback"
      status: IMPLEMENTED
  key_links:
    - from: "app_core/mod.rs"
      to: "engine::EngineThreadChannels"
      via: "command sending"
      pattern: "gpu_command_sender\\.push"
      status: NOT IMPLEMENTED
    - from: "engine_core.rs"
      to: "protocol::GpuFeedbackFrame"
      via: "feedback consumption"
      pattern: "gpu_feedback_receiver\\.pop"
      status: IMPLEMENTED
---

<objective>
Migrate AppCore to send commands via channel and consume feedback, completing the two-thread architecture integration.

Purpose: Replace direct GpuRuntime::execute() calls with channel-based communication, enabling true concurrent execution between engine thread (business logic) and main thread (GPU execution).

Output:
- All AppCore operations send RuntimeCommand via channel
- EngineCore consumes GpuFeedbackFrame and processes receipts/errors
- Waterline tracking functional end-to-end
- All renderer tests pass in two-thread mode
</objective>

<execution_context>
@/home/sunastans/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/sunastans/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@docs/planning/roadmap.md
@docs/planning/state.md
@docs/planning/phases/04-01-channel-infrastructure/04-01-SUMMARY.md
@docs/planning/phases/04-02-runtime-thread-loop/04-02-SUMMARY.md
@crates/glaphica/src/app_core/mod.rs
@crates/glaphica/src/engine_core.rs
@crates/glaphica/src/engine_bridge.rs
@crates/glaphica/src/runtime/execution.rs
</context>

<interfaces>
From crates/engine/src/lib.rs:
```rust
pub struct EngineThreadChannels<Command, Receipt, Error> {
    pub input_ring_consumer: InputRingConsumer,
    pub input_control_sender: InputControlSender,
    pub gpu_command_sender: GpuCommandSender<Command>,
    pub gpu_feedback_receiver: GpuFeedbackReceiver<Receipt, Error>,
}

pub struct MainThreadChannels<Command, Receipt, Error> {
    pub input_ring_producer: InputRingProducer,
    pub input_control_receiver: InputControlReceiver,
    pub gpu_command_receiver: GpuCommandReceiver<Command>,
    pub gpu_feedback_sender: GpuFeedbackSender<Receipt, Error>,
}
```

From crates/protocol/src/lib.rs:
```rust
pub struct GpuCmdMsg<Command> {
    pub waterline: SubmitWaterline,
    pub input_sample: Option<InputRingSample>,
    pub payload: GpuCmdPayload<Command>,
}

pub enum GpuCmdPayload<Command> {
    Command(Command),
    Control(InputControlEvent),
}

pub struct GpuFeedbackFrame<Receipt, Error> {
    pub present_frame_id: PresentFrameId,
    pub submit_waterline: SubmitWaterline,
    pub executed_batch_waterline: ExecutedBatchWaterline,
    pub complete_waterline: CompleteWaterline,
    pub receipts: ThinVec<Receipt>,
    pub errors: ThinVec<Error>,
}
```
</interfaces>

<tasks>

<task type="auto" tdd="true">
  <name>Task 1: Migrate render()/present() path to channel</name>
  <files>crates/glaphica/src/app_core/mod.rs, crates/glaphica/src/engine_core.rs</files>
  <behavior>
    - Test: render() sends PresentFrame command via channel
    - Test: Feedback received with FramePresented receipt
    - Test: Waterline updated after feedback processed
    - Edge case: Channel full should return error gracefully
  </behavior>
  <action>
    1. In app_core/mod.rs, add channel fields to AppCore:
       - `gpu_command_sender: GpuCommandSender&lt;RuntimeCommand&gt;`
       - `gpu_feedback_receiver: GpuFeedbackReceiver&lt;RuntimeReceipt, RuntimeError&gt;`
    2. Modify AppCore::render() to:
       - Send RuntimeCommand::PresentFrame { frame_id } via channel
       - Drain feedback from gpu_feedback_receiver
       - Return based on feedback receipts
    3. In engine_core.rs, process_feedback() already handles FramePresented receipt
    4. Update GpuState::render() to use new AppCore API
  </action>
  <verify>
    <automated>cargo test -p glaphica appcore_render_channel -- --nocapture</automated>
  </verify>
  <done>
    - AppCore::render() uses channel, not direct execute()
    - PresentFrame command sent and acknowledged
    - Feedback processed, waterline updated
    - Test passes: render frame, verify receipt received
  </done>
</task>

<task type="auto" tdd="true">
  <name>Task 2: Migrate resize() path to channel</name>
  <files>crates/glaphica/src/app_core/mod.rs, crates/glaphica/src/engine_bridge.rs</files>
  <behavior>
    - Test: resize() sends Resize command with handshake
    - Test: Synchronous wait for ResizeHandshakeAck
    - Test: Timeout after 1 second if no ack
    - Edge case: Resize error should propagate to caller
  </behavior>
  <action>
    1. Modify AppCore::resize() to use handshake pattern:
       - Create sync channel: `let (ack_tx, ack_rx) = bounded(1)`
       - Send RuntimeCommand::ResizeHandshake { width, height, ack_sender: ack_tx }
       - Wait for ack with timeout: `ack_rx.recv_timeout(Duration::from_secs(1))`
       - Return Result based on ack result
    2. EngineBridge already handles ResizeHandshake command
    3. Update GpuState::resize() to use new AppCore API
  </action>
  <verify>
    <automated>cargo test -p glaphica appcore_resize_channel -- --nocapture</automated>
  </verify>
  <done>
    - AppCore::resize() uses handshake channel
    - ResizeHandshakeAck received
    - Timeout works correctly
    - Test passes: resize, verify ack received within timeout
  </done>
</task>

<task type="auto" tdd="true">
  <name>Task 3: Migrate brush enqueue path to channel</name>
  <files>crates/glaphica/src/app_core/mod.rs</files>
  <behavior>
    - Test: enqueue_brush_render_command() sends EnqueueBrushCommands
    - Test: BrushCommandEnqueued receipt received
    - Test: Multiple commands can be batched
    - Edge case: Command queue full should return error
  </behavior>
  <action>
    1. Modify AppCore::enqueue_brush_render_command() to:
       - Send RuntimeCommand::EnqueueBrushCommands { commands } via channel
       - Batch multiple brush commands when possible
       - Wait for feedback or return immediately based on mode
    2. For async mode: return immediately after send
    3. For sync mode: drain feedback until BrushCommandEnqueued receipt
  </action>
  <verify>
    <automated>cargo test -p glaphica appcore_brush_channel -- --nocapture</automated>
  </verify>
  <done>
    - AppCore::enqueue_brush_render_command() uses channel
    - Brush commands sent successfully
    - Receipts processed
    - Test passes: enqueue brush command, verify receipt
  </done>
</task>

<task type="auto" tdd="true">
  <name>Task 4: Migrate merge polling path to channel</name>
  <files>crates/glaphica/src/app_core/mod.rs, crates/glaphica/src/engine_core.rs</files>
  <behavior>
    - Test: poll_merge_completions() sends PollMergeNotices command
    - Test: MergeNotices receipt with notices returned
    - Test: process_merge_completions() sends ProcessMergeCompletions
    - Edge case: No notices available returns empty vec
  </behavior>
  <action>
    1. Modify AppCore::poll_merge_completions() to:
       - Send RuntimeCommand::PollMergeNotices { frame_id }
       - Drain feedback until MergeNotices receipt
       - Return notices from receipt
    2. Modify AppCore::process_merge_completions() to:
       - Send RuntimeCommand::ProcessMergeCompletions { frame_id }
       - Drain feedback until MergeCompletionsProcessed receipt
    3. EngineCore::process_feedback() handles merge receipts
  </action>
  <verify>
    <automated>cargo test -p glaphica appcore_merge_channel -- --nocapture</automated>
  </verify>
  <done>
    - Merge polling uses channel
    - Merge completions processed via channel
    - Notices returned correctly
    - Test passes: poll merge, verify notices received
  </done>
</task>

<task type="auto">
  <name>Task 5: Implement feedback processing loop</name>
  <files>crates/glaphica/src/engine_core.rs</files>
  <action>
    1. EngineCore::process_feedback() already implemented - verify completeness
    2. Ensure all RuntimeReceipt variants handled in apply_receipt():
       - FramePresented, Resized, ResizeHandshakeAck, InitComplete, ShutdownAck
       - RenderTreeBound, BrushCommandsEnqueued, BrushCommandEnqueued
       - MergeNotices, MergeCompletionsProcessed, MergeResultsAcknowledged, PlannedMergeEnqueued
    3. Ensure all RuntimeError variants handled in handle_error():
       - PresentError, SurfaceError, ResizeError, BrushEnqueueError
       - MergeSubmit, MergePoll, MergeAck, MergeEnqueue
       - ShutdownRequested, EngineThreadDisconnected, FeedbackQueueTimeout, HandshakeTimeout
    4. Add waterline-based GC in gc_evict_before_waterline()
  </action>
  <verify>
    <automated>cargo test -p glaphica feedback_processing -- --nocapture</automated>
  </verify>
  <done>
    - All receipt variants handled
    - All error variants handled
    - Waterline tracking functional
    - GC eviction implemented
    - Test passes: send feedback, verify processing
  </done>
</task>

<task type="auto">
  <name>Task 6: Run all renderer tests in two-thread mode</name>
  <files>crates/renderer/tests/*, crates/glaphica/src/phase4_threaded_tests.rs</files>
  <action>
    1. Enable true_threading feature for tests
    2. Run renderer test suite: cargo test -p renderer --features true_threading
    3. Fix any failing tests due to channel semantics
    4. Document any known test failures
  </action>
  <verify>
    <automated>cargo test -p renderer --features true_threading -- --nocapture</automated>
  </verify>
  <done>
    - All 47 renderer tests pass
    - No new test failures introduced
    - Known failures documented
  </done>
</task>

</tasks>

<verification>
Phase 4.3 verification:
1. AppCore::render() sends PresentFrame via channel, receives FramePresented receipt
2. AppCore::resize() uses handshake, receives ResizeHandshakeAck
3. AppCore::enqueue_brush_render_command() sends EnqueueBrushCommands
4. AppCore::poll_merge_completions() uses PollMergeNotices command
5. EngineCore::process_feedback() handles all receipt/error variants
6. Waterline tracking end-to-end functional
7. All renderer tests pass in two-thread mode

Manual verification:
- Build with --features true_threading
- Run application, verify no deadlocks
- Check waterline monotonicity in debug logs
</verification>

<success_criteria>
1. ✓ All AppCore operations use channel communication
2. ✓ Feedback processing complete
3. ✓ Waterline tracking functional
4. ✓ All renderer tests pass
5. ✓ No deadlocks or race conditions
6. ✓ Code compiles with true_threading feature
7. ✓ No new warnings introduced
</success_criteria>

<output>
After completion, create `docs/planning/phases/04-03-appcore-migration/04-03-SUMMARY.md` documenting:
- Migration approach for each command path
- Feedback processing implementation
- Test results and any known issues
- Deviations from plan
</output>
