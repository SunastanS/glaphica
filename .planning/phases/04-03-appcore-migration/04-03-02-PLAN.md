---
phase: 04-03-appcore-migration
plan: 02
type: execute
wave: 2
depends_on: [04-03-01]
files_modified:
  - crates/glaphica/src/app_core/mod.rs
autonomous: true
gap_closure: true
requirements: [CMD-01, CMD-02]

must_haves:
  truths:
    - "AppCore::render() sends PresentFrame via channel when channels available"
    - "AppCore::resize() sends Resize via channel when channels available"
    - "Direct runtime.execute() calls are replaced with channel sends in threaded mode"
  artifacts:
    - path: "crates/glaphica/src/app_core/mod.rs"
      provides: "Channel-based render/resize paths"
      contains: "gpu_command_sender.push"
  key_links:
    - from: "AppCore::render()"
      to: "gpu_command_sender"
      via: "GpuCmdMsg::Command(PresentFrame)"
      pattern: "PresentFrame.*channel"
    - from: "AppCore::resize()"
      to: "gpu_command_sender"
      via: "GpuCmdMsg::Command(Resize)"
      pattern: "Resize.*channel"
---

<objective>
Migrate AppCore::render() and AppCore::resize() to send commands via channel in threaded mode.

Purpose: Replace direct runtime.execute() calls with channel-based communication for render and resize paths.
Output: render() and resize() methods that use channels when available, fallback to direct calls otherwise.
</objective>

<execution_context>
@/home/sunastans/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/sunastans/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior Plan Context
@.planning/phases/04-03-appcore-migration/04-03-01-PLAN.md

<interfaces>
<!-- Key types from Phase 4.1/4.2 infrastructure -->

From crates/glaphica/src/app_core/mod.rs (current implementation):
```rust
// Line 357-393: render() method
pub fn render(&mut self, runtime: &mut GpuRuntime) -> Result<(), AppCoreError> {
    runtime.drain_view_ops();
    let frame_id = self.get_next_frame_id();
    match runtime.execute(RuntimeCommand::PresentFrame { frame_id }) {
        Ok(RuntimeReceipt::FramePresented { .. }) => Ok(()),
        // ... error handling
    }
}

// Line 322-350: resize() method  
pub fn resize(&mut self, runtime: &mut GpuRuntime, new_size: PhysicalSize<u32>) -> Result<(), AppCoreError> {
    // ... size validation ...
    runtime.execute(RuntimeCommand::Resize { width, height, view_transform })
        .map_err(|err| AppCoreError::Resize { ... })?;
    Ok(())
}
```

From crates/glaphica/src/engine_bridge.rs (pattern to follow):
```rust
// How EngineBridge sends commands:
channels.gpu_command_sender.push(protocol::GpuCmdMsg::Command(cmd))

// How EngineBridge receives feedback:
while let Ok(frame) = channels.gpu_feedback_receiver.pop() {
    // process feedback
}
```

From crates/protocol/src/lib.rs:
```rust
pub struct GpuCmdMsg<Command> {
    // Wrapper for commands in channel
    // Use GpuCmdMsg::Command(cmd) to wrap
}
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate AppCore::render() to channel-based communication</name>
  <files>crates/glaphica/src/app_core/mod.rs</files>
  <action>
Refactor AppCore::render() to use channels when available:

1. Check if channels are present (has_channels())
2. If channels available:
   - Send PresentFrame via gpu_command_sender
   - Optionally wait for feedback from gpu_feedback_receiver (or process in separate method)
3. If no channels (single-threaded mode):
   - Keep existing runtime.execute() call

Pattern:
```rust
pub fn render(&mut self, runtime: &mut GpuRuntime) -> Result<(), AppCoreError> {
    runtime.drain_view_ops();
    let frame_id = self.get_next_frame_id();
    
    #[cfg(feature = "true_threading")]
    if let Some(ref sender) = self.gpu_command_sender {
        // Threaded mode: send via channel
        let cmd = RuntimeCommand::PresentFrame { frame_id };
        sender.push(protocol::GpuCmdMsg::Command(cmd))
            .map_err(|_| AppCoreError::ChannelSendFailed { command: "PresentFrame" })?;
        // Note: Feedback will be processed separately by process_feedback()
        return Ok(());
    }
    
    // Single-threaded mode: direct execute
    match runtime.execute(RuntimeCommand::PresentFrame { frame_id }) {
        Ok(RuntimeReceipt::FramePresented { .. }) => Ok(()),
        // ... existing error handling
    }
}
```

IMPORTANT: Keep the exact same error handling logic for single-threaded mode. Only add the channel path.
  </action>
  <verify>
    <automated>cargo check -p glaphica --features true_threading</automated>
  </verify>
  <done>render() sends PresentFrame via channel in threaded mode, uses direct execute() in single-threaded mode</done>
</task>

<task type="auto">
  <name>Task 2: Migrate AppCore::resize() to channel-based communication</name>
  <files>crates/glaphica/src/app_core/mod.rs</files>
  <action>
Refactor AppCore::resize() to use channels when available:

1. Check if channels are present
2. If channels available:
   - Send Resize via gpu_command_sender
   - For resize, this is typically synchronous - consider blocking wait for feedback
3. If no channels:
   - Keep existing runtime.execute() call

Pattern:
```rust
pub fn resize(&mut self, runtime: &mut GpuRuntime, new_size: PhysicalSize<u32>) -> Result<(), AppCoreError> {
    let width = new_size.width.max(1);
    let height = new_size.height.max(1);
    
    // Skip if unchanged
    let current_size = runtime.surface_size();
    if current_size.width == width && current_size.height == height {
        return Ok(());
    }
    
    #[cfg(feature = "true_threading")]
    if let Some(ref sender) = self.gpu_command_sender {
        // Threaded mode: send via channel
        let cmd = RuntimeCommand::Resize {
            width,
            height,
            view_transform: self.view_transform.clone(),
        };
        sender.push(protocol::GpuCmdMsg::Command(cmd))
            .map_err(|_| AppCoreError::ChannelSendFailed { command: "Resize" })?;
        // Note: Resize is typically synchronous in wgpu, so may need feedback wait
        return Ok(());
    }
    
    // Single-threaded mode: direct execute
    runtime.execute(RuntimeCommand::Resize { width, height, view_transform: self.view_transform.clone() })
        .map_err(|err| AppCoreError::Resize { width, height, reason: format!("{:?}", err) })?;
    Ok(())
}
```

Note: Add AppCoreError::ChannelSendFailed variant if not present.
  </action>
  <verify>
    <automated>cargo check -p glaphica --features true_threading</automated>
  </verify>
  <done>resize() sends Resize via channel in threaded mode, uses direct execute() in single-threaded mode</done>
</task>

<task type="auto">
  <name>Task 3: Add AppCoreError variant for channel failures</name>
  <files>crates/glaphica/src/app_core/mod.rs</files>
  <action>
Add error variant for channel communication failures in the AppCoreError enum:

```rust
pub enum AppCoreError {
    // ... existing variants ...
    
    /// Channel send operation failed (queue full or disconnected).
    ChannelSendFailed {
        command: &'static str,
    },
    
    /// Channel receive operation failed (queue empty or disconnected).
    ChannelReceiveFailed {
        context: &'static str,
    },
}
```

This provides clear error handling for channel operations.
  </action>
  <verify>
    <automated>cargo check -p glaphica --features true_threading</automated>
  </verify>
  <done>AppCoreError has ChannelSendFailed and ChannelReceiveFailed variants</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `cargo check -p glaphica` passes (single-threaded mode)
2. `cargo check -p glaphica --features true_threading` passes (threaded mode)
3. render() and resize() have conditional paths for channel vs direct execution
</verification>

<success_criteria>
1. AppCore::render() sends PresentFrame via channel when channels are available
2. AppCore::resize() sends Resize via channel when channels are available
3. Both methods fall back to runtime.execute() when channels are not available
4. New error variants added for channel failures
5. Code compiles with both feature configurations
</success_criteria>

<output>
After completion, create `.planning/phases/04-03-appcore-migration/04-03-02-SUMMARY.md`
</output>