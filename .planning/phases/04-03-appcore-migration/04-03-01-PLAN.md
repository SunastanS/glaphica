---
phase: 04-03-appcore-migration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/glaphica/src/app_core/mod.rs
  - crates/glaphica/src/gpu_state.rs
autonomous: true
gap_closure: true
requirements: [CMD-01, CMD-02, CMD-03, CMD-04, CMD-05]

must_haves:
  truths:
    - "AppCore struct has gpu_command_sender field"
    - "AppCore struct has gpu_feedback_receiver field"
    - "AppCore::new() accepts channel parameters"
    - "GpuState creates channels and passes them to AppCore"
  artifacts:
    - path: "crates/glaphica/src/app_core/mod.rs"
      provides: "AppCore with channel fields"
      contains: "gpu_command_sender"
    - path: "crates/glaphica/src/gpu_state.rs"
      provides: "Channel creation and AppCore construction"
  key_links:
    - from: "GpuState::new()"
      to: "AppCore::new()"
      via: "channel parameters"
      pattern: "create_thread_channels"
---

<objective>
Add channel fields to AppCore and refactor construction to accept channel parameters.

Purpose: Establish the foundation for channel-based communication between AppCore and GpuRuntime.
Output: AppCore with gpu_command_sender and gpu_feedback_receiver fields, GpuState creating and passing channels.
</objective>

<execution_context>
@/home/sunastans/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/sunastans/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior Phase Context
@.planning/phases/04-01-channel-infrastructure/04-01-SUMMARY.md
@.planning/phases/04-01-channel-infrastructure/04-02-SUMMARY.md

<interfaces>
<!-- Key types and contracts from existing infrastructure -->

From crates/engine/src/lib.rs:
```rust
pub struct EngineThreadChannels<Command, Receipt, Error> {
    pub input_control_queue: EngineInputControlQueue,
    pub input_ring_consumer: EngineInputRingConsumer,
    pub gpu_command_sender: Producer<GpuCmdMsg<Command>>,
    pub gpu_feedback_receiver: Consumer<GpuFeedbackFrame<Receipt, Error>>,
}
```

From crates/protocol/src/lib.rs:
```rust
pub struct GpuCmdMsg<Command> {
    // Command wrapper for channel transport
}

pub struct GpuFeedbackFrame<Receipt, Error> {
    pub receipts: Vec<Receipt>,
    pub errors: Vec<Error>,
    pub submit_waterline: SubmitWaterline,
    pub executed_batch_waterline: ExecutedBatchWaterline,
    pub complete_waterline: CompleteWaterline,
}
```

From crates/glaphica/src/runtime/protocol.rs:
```rust
pub enum RuntimeCommand {
    PresentFrame { frame_id: u64 },
    Resize { width: u32, height: u32, view_transform: ViewTransform },
    EnqueueBrushCommand { command: BrushRenderCommand },
    ProcessMergeCompletions { frame_id: u64 },
    AckMergeResults { notices: Vec<MergeCompletionNotice> },
    EnqueuePlannedMerge { receipt: ..., gpu_merge_ops: ..., meta: ... },
    // ... other variants
}

pub enum RuntimeReceipt { ... }
pub enum RuntimeError { ... }
```

From crates/glaphica/src/engine_core.rs:
```rust
pub struct EngineCore {
    pub document: Document,
    pub tile_merge_engine: TileMergeEngine<MergeStores>,
    pub brush_buffer_tile_keys: BrushBufferTileRegistry,
    pub view_transform: ViewTransform,
    pub waterlines: EngineWaterlines,
    pub pending_commands: Vec<RuntimeCommand>,
    // ... other fields
}
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add channel fields to AppCore struct</name>
  <files>crates/glaphica/src/app_core/mod.rs</files>
  <action>
Add optional channel fields to AppCore struct. The fields should be Option-wrapped to support both single-threaded mode (None) and threaded mode (Some):

```rust
pub struct AppCore {
    // ... existing fields ...
    
    /// Channel sender for GPU commands (threaded mode only).
    /// When present, AppCore sends RuntimeCommand via this channel instead of calling runtime.execute() directly.
    #[cfg(feature = "true_threading")]
    gpu_command_sender: Option<rtrb::Producer<protocol::GpuCmdMsg<RuntimeCommand>>>,
    
    /// Channel receiver for GPU feedback (threaded mode only).
    /// When present, AppCore receives RuntimeReceipt/RuntimeError via this channel.
    #[cfg(feature = "true_threading")]
    gpu_feedback_receiver: Option<rtrb::Consumer<protocol::GpuFeedbackFrame<RuntimeReceipt, RuntimeError>>>,
}
```

Note: Use `#[cfg(feature = "true_threading")]` for conditional compilation, matching the pattern from Phase 4.1/4.2.
  </action>
  <verify>
    <automated>cargo check -p glaphica --features true_threading</automated>
  </verify>
  <done>AppCore struct compiles with channel fields, both with and without true_threading feature</done>
</task>

<task type="auto">
  <name>Task 2: Update AppCore::new() to accept channel parameters</name>
  <files>crates/glaphica/src/app_core/mod.rs</files>
  <action>
Update AppCore::new() to optionally accept channel parameters:

1. Add new constructor variant or update existing:
```rust
impl AppCore {
    /// Create AppCore with channel communication (threaded mode).
    #[cfg(feature = "true_threading")]
    pub fn new_with_channels(
        // ... existing parameters ...
        gpu_command_sender: rtrb::Producer<protocol::GpuCmdMsg<RuntimeCommand>>,
        gpu_feedback_receiver: rtrb::Consumer<protocol::GpuFeedbackFrame<RuntimeReceipt, RuntimeError>>,
    ) -> Self {
        Self {
            // ... existing fields ...
            gpu_command_sender: Some(gpu_command_sender),
            gpu_feedback_receiver: Some(gpu_feedback_receiver),
        }
    }
}
```

2. Keep existing new() for single-threaded mode (channels as None).

3. Add helper method to check if channels are available:
```rust
#[cfg(feature = "true_threading")]
fn has_channels(&self) -> bool {
    self.gpu_command_sender.is_some() && self.gpu_feedback_receiver.is_some()
}
```
  </action>
  <verify>
    <automated>cargo check -p glaphica --features true_threading</automated>
  </verify>
  <done>AppCore::new_with_channels() compiles, existing new() unchanged for backward compatibility</done>
</task>

<task type="auto">
  <name>Task 3: Update GpuState to create channels and pass to AppCore</name>
  <files>crates/glaphica/src/gpu_state.rs</files>
  <action>
Update GpuState construction to create channels using engine::create_thread_channels() and pass them to AppCore:

1. Find where AppCore is constructed in GpuState (likely in GpuState::new() or similar).

2. Add channel creation before AppCore construction:
```rust
#[cfg(feature = "true_threading")]
{
    let (main_channels, engine_channels) = engine::create_thread_channels::<
        RuntimeCommand, RuntimeReceipt, RuntimeError
    >(
        1024, // input_ring_capacity
        64,   // input_control_capacity
        256,  // gpu_command_capacity
        64,   // gpu_feedback_capacity
    );
    
    // Pass engine_channels.gpu_command_sender and gpu_feedback_receiver to AppCore
    // Keep main_channels for EngineBridge
}
```

3. For single-threaded mode (no feature), keep existing AppCore::new() call.

Reference the pattern from Phase 4.2 where channels were instantiated in GpuState.
  </action>
  <verify>
    <automated>cargo check -p glaphica --features true_threading && cargo check -p glaphica</automated>
  </verify>
  <done>GpuState creates channels and passes to AppCore in threaded mode, single-threaded mode unchanged</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `cargo check -p glaphica` passes (single-threaded mode)
2. `cargo check -p glaphica --features true_threading` passes (threaded mode)
3. No new dead_code warnings introduced
</verification>

<success_criteria>
1. AppCore struct has gpu_command_sender and gpu_feedback_receiver fields (feature-gated)
2. AppCore::new_with_channels() accepts channel parameters
3. GpuState creates channels using create_thread_channels()
4. Code compiles with both feature configurations
5. No functional changes to existing behavior (single-threaded mode unchanged)
</success_criteria>

<output>
After completion, create `.planning/phases/04-03-appcore-migration/04-03-01-SUMMARY.md`
</output>