---
phase: 04-03-appcore-migration
plan: 03
type: execute
wave: 3
depends_on: [04-03-02]
files_modified:
  - crates/glaphica/src/app_core/mod.rs
autonomous: true
gap_closure: true
requirements: [CMD-03, CMD-04]

must_haves:
  truths:
    - "AppCore::enqueue_brush_render_command() sends EnqueueBrushCommand via channel in threaded mode"
    - "AppCore::process_renderer_merge_completions() sends ProcessMergeCompletions via channel"
    - "All runtime.execute() calls in brush/merge paths are replaced with channel sends"
  artifacts:
    - path: "crates/glaphica/src/app_core/mod.rs"
      provides: "Channel-based brush/merge paths"
      contains: "EnqueueBrushCommand.*channel"
  key_links:
    - from: "AppCore::enqueue_brush_render_command()"
      to: "gpu_command_sender"
      via: "GpuCmdMsg::Command(EnqueueBrushCommand)"
    - from: "AppCore::process_renderer_merge_completions()"
      to: "gpu_command_sender"
      via: "GpuCmdMsg::Command(ProcessMergeCompletions)"
---

<objective>
Migrate AppCore brush and merge operations to send commands via channel in threaded mode.

Purpose: Replace remaining runtime.execute() calls with channel-based communication for brush enqueue, merge processing, and related operations.
Output: All brush/merge methods that use channels when available, fallback to direct calls otherwise.
</objective>

<execution_context>
@/home/sunastans/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/sunastans/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior Plan Context
@.planning/phases/04-03-appcore-migration/04-03-02-PLAN.md

<interfaces>
<!-- Locations of runtime.execute() calls in brush/merge paths -->

From crates/glaphica/src/app_core/mod.rs:
```rust
// Lines 408, 457, 503, 518: enqueue_brush_render_command()
runtime.execute(RuntimeCommand::EnqueueBrushCommand { command: command.clone() })

// Line 544: process_renderer_merge_completions()
runtime.execute(RuntimeCommand::ProcessMergeCompletions { frame_id })

// Line 623: process_renderer_merge_completions() ack path
runtime.execute(RuntimeCommand::AckMergeResults { notices: notices_to_ack })

// Line 1041: enqueue_stroke_merge_submission()
runtime.execute(RuntimeCommand::EnqueuePlannedMerge { receipt, gpu_merge_ops, meta })
```

Channel send pattern (from Plan 02):
```rust
#[cfg(feature = "true_threading")]
if let Some(ref sender) = self.gpu_command_sender {
    sender.push(protocol::GpuCmdMsg::Command(cmd))?;
    return Ok(());
}
// Fall through to direct execute
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate enqueue_brush_render_command() to channel-based communication</name>
  <files>crates/glaphica/src/app_core/mod.rs</files>
  <action>
Refactor enqueue_brush_render_command() to use channels when available.

This method has multiple runtime.execute() calls at lines 408, 457, 503, 518.

Pattern for each location:
```rust
#[cfg(feature = "true_threading")]
if let Some(ref sender) = self.gpu_command_sender {
    let cmd = RuntimeCommand::EnqueueBrushCommand { command: command.clone() };
    sender.push(protocol::GpuCmdMsg::Command(cmd))
        .map_err(|e| {
            BrushRenderEnqueueError::ChannelError {
                message: format!("failed to send brush command: {:?}", e)
            }
        })?;
    // Continue with remaining logic
} else {
    // Existing direct execute
    runtime.execute(RuntimeCommand::EnqueueBrushCommand { command: command.clone() })?;
}
```

IMPORTANT: 
- Maintain the existing logic flow for each BrushRenderCommand variant
- The method still needs access to runtime for brush_buffer_store() and bind_brush_buffer_tiles()
- Only replace the execute() calls with channel sends
- Add BrushRenderEnqueueError::ChannelError variant if needed
  </action>
  <verify>
    <automated>cargo check -p glaphica --features true_threading</automated>
  </verify>
  <done>enqueue_brush_render_command() sends EnqueueBrushCommand via channel in threaded mode</done>
</task>

<task type="auto">
  <name>Task 2: Migrate process_renderer_merge_completions() to channel-based communication</name>
  <files>crates/glaphica/src/app_core/mod.rs</files>
  <action>
Refactor process_renderer_merge_completions() to use channels when available.

This method has runtime.execute() calls at:
- Line 544: ProcessMergeCompletions
- Line 623: AckMergeResults

Pattern:
```rust
// For ProcessMergeCompletions (line 544)
#[cfg(feature = "true_threading")]
let receipt = if let Some(ref sender) = self.gpu_command_sender {
    let cmd = RuntimeCommand::ProcessMergeCompletions { frame_id };
    sender.push(protocol::GpuCmdMsg::Command(cmd))?;
    
    // Need to receive feedback - this is more complex
    // Option 1: Wait for specific receipt
    // Option 2: Process feedback in separate method
    // For now, use a synchronous wait pattern
    self.wait_for_receipt()?
} else {
    runtime.execute(RuntimeCommand::ProcessMergeCompletions { frame_id })?
};

// For AckMergeResults (line 623)
#[cfg(feature = "true_threading")]
if let Some(ref sender) = self.gpu_command_sender {
    let cmd = RuntimeCommand::AckMergeResults { notices: notices_to_ack.clone() };
    sender.push(protocol::GpuCmdMsg::Command(cmd))?;
} else {
    runtime.execute(RuntimeCommand::AckMergeResults { notices: notices_to_ack })?;
}
```

Note: This method returns RuntimeReceipt::MergeCompletionsProcessed with data needed for business logic. The channel-based version needs to handle receiving this receipt.
  </action>
  <verify>
    <automated>cargo check -p glaphica --features true_threading</automated>
  </verify>
  <done>process_renderer_merge_completions() sends ProcessMergeCompletions and AckMergeResults via channels</done>
</task>

<task type="auto">
  <name>Task 3: Migrate enqueue_stroke_merge_submission() to channel-based communication</name>
  <files>crates/glaphica/src/app_core/mod.rs</files>
  <action>
Refactor enqueue_stroke_merge_submission() to use channels when available.

Location: Line 1040-1051

Pattern:
```rust
#[cfg(feature = "true_threading")]
if let Some(ref sender) = self.gpu_command_sender {
    let cmd = RuntimeCommand::EnqueuePlannedMerge {
        receipt: submission.renderer_submit_payload.receipt,
        gpu_merge_ops: submission.renderer_submit_payload.gpu_merge_ops,
        meta: submission.renderer_submit_payload.meta,
    };
    sender.push(protocol::GpuCmdMsg::Command(cmd))
        .map_err(|e| MergeBridgeError::ChannelError {
            message: format!("failed to send planned merge: {:?}", e)
        })?;
} else {
    runtime.execute(RuntimeCommand::EnqueuePlannedMerge { ... })?;
}
```

Add MergeBridgeError::ChannelError variant if needed.
  </action>
  <verify>
    <automated>cargo check -p glaphica --features true_threading</automated>
  </verify>
  <done>enqueue_stroke_merge_submission() sends EnqueuePlannedMerge via channel in threaded mode</done>
</task>

<task type="auto">
  <name>Task 4: Add helper method for waiting on feedback receipt</name>
  <files>crates/glaphica/src/app_core/mod.rs</files>
  <action>
Add a helper method to wait for feedback from the channel when needed for synchronous operations:

```rust
#[cfg(feature = "true_threading")]
fn wait_for_feedback(&mut self) -> Result<protocol::GpuFeedbackFrame<RuntimeReceipt, RuntimeError>, AppCoreError> {
    use std::time::{Duration, Instant};
    let timeout = Duration::from_millis(100);
    let start = Instant::now();
    
    if let Some(ref receiver) = self.gpu_feedback_receiver {
        loop {
            match receiver.pop() {
                Ok(frame) => return Ok(frame),
                Err(rtrb::PopError::Empty) => {
                    if start.elapsed() > timeout {
                        return Err(AppCoreError::ChannelReceiveFailed {
                            context: "wait_for_feedback timeout"
                        });
                    }
                    std::thread::yield_now();
                }
            }
        }
    } else {
        Err(AppCoreError::ChannelReceiveFailed {
            context: "no feedback receiver"
        })
    }
}
```

This helper is used by process_renderer_merge_completions() to wait for the MergeCompletionsProcessed receipt.
  </action>
  <verify>
    <automated>cargo check -p glaphica --features true_threading</automated>
  </verify>
  <done>Helper method wait_for_feedback() available for synchronous receipt waiting</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `cargo check -p glaphica` passes (single-threaded mode)
2. `cargo check -p glaphica --features true_threading` passes (threaded mode)
3. All 9 runtime.execute() calls in app_core/mod.rs have channel alternatives
</verification>

<success_criteria>
1. enqueue_brush_render_command() uses channels for EnqueueBrushCommand
2. process_renderer_merge_completions() uses channels for ProcessMergeCompletions and AckMergeResults
3. enqueue_stroke_merge_submission() uses channels for EnqueuePlannedMerge
4. Helper method for feedback waiting implemented
5. All methods fall back to runtime.execute() when channels unavailable
6. Code compiles with both feature configurations
</success_criteria>

<output>
After completion, create `.planning/phases/04-03-appcore-migration/04-03-03-SUMMARY.md`
</output>